site: LeetCode
code: LC0020
title: Valid Parentheses
difficulty: Easy
topics: [string, stack]
status: solved

Условие (своими словами):
Дана строка s, содержащая только символы '(', ')', '{', '}', '[' и ']'.  
Нужно проверить, является ли она «валидной»:  
- Каждая открывающая скобка должна закрываться той же скобкой.  
- Скобки должны закрываться в правильном порядке.  

Вход/Выход:
- Вход: string s
- Выход: bool (true, если строка валидна; false иначе)

Примеры:
1) s="()" → true  
2) s="()[]{}" → true  
3) s="(]" → false  
4) s="([)]" → false  
5) s="{[]}" → true  

Ограничения:
- 1 ≤ s.Length ≤ 10⁴  
- Строка состоит только из символов ()[]{}  

Идея (без кода):
1) Использовать стек.  
2) При встрече открывающей скобки — положить её в стек.  
3) При встрече закрывающей — проверить, что стек не пуст и верх стека совпадает по типу. Если совпадает — убрать верхний элемент, иначе вернуть false.  
4) После обработки всей строки стек должен быть пуст.  

Сложность (target):
Время O(n), память O(n).

Тесты (ручные):
- edge: s="(" → false  
- edge: s="]" → false  
- edge: s="({[" → false  
- normal: s="()" → true  
- normal: s="()[]{}" → true  
- normal: s="(]" → false  
- normal: s="([)]" → false  
- sanity: s="{[]}" → true  
- sanity: s="((()))" → true  

Отчёт по решению (короткий):
Подход: стек для отслеживания открывающих скобок и проверка при закрытии.  
Почему работает: корректная пара закрывается только при совпадении типов, а стек хранит порядок вложенности.  
Сложность: время O(n), память O(n).  
Ошибки/подводные: забыть проверить пустоту стека в конце; перепутать соответствие типов; не учесть строку из одной закрывающей.  
Что выучил: базовый шаблон «парсинг с балансом скобок» через стек.
