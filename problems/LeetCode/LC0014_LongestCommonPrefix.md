site: LeetCode
code: LC0014
title: Longest Common Prefix
difficulty: Easy
topics: [string, scanning, sorting]
status: solved

Условие (своими словами):
Дан массив строк strs. Найти самый длинный общий префикс для всех строк. Если общего префикса нет — вернуть пустую строку "".

Вход/Выход:
- Вход: string[] strs
- Выход: string prefix

Примеры:
1) ["flower","flow","flight"] → "fl"
2) ["dog","racecar","car"] → ""
3) ["a"] → "a"
4) ["","b"] → ""
5) ["ab","a"] → "a"

Ограничения (типичные для задачи):
- 1 ≤ strs.Length ≤ ~200
- 0 ≤ strs[i].Length ≤ ~200
- Строки — строчные латинские буквы

Идея (без кода):
Вариант A (вертикальное сканирование):
1) Найти самую короткую строку (она ограничивает длину ответа).
2) Идти по позициям i от 0 до minLen-1, брать опорный символ c из короткой строки.
3) Проверять у всех строк символ на i. При первом несовпадении вернуть префикс до i.

Вариант B (сортировка строк):
1) Отсортировать strs лексикографически.
2) Общий префикс совпадает у первой и последней строк — сравнить их посимвольно до расхождения.

Сложность (target):
- Вариант A: время O(n * m), память O(1), где n — число строк, m — длина минимальной строки.
- Вариант B: время O(n log n + m), память O(1) (если сортировка in-place).

Тесты (ручные):
- edge: [""] → ""
- edge: ["",""] → ""
- edge: ["a",""] → ""
- normal: ["flower","flow","flight"] → "fl"
- normal: ["dog","racecar","car"] → ""
- normal: ["interspecies","interstellar","interstate"] → "inters"
- normal: ["ab","a"] → "a"
- sanity: ["same","same","same"] → "same"

Отчёт по решению (короткий):
Подход: вертикальное сканирование (или сортировка и сравнение первой/последней).
Почему работает: общая длина префикса ограничена длиной минимальной строки; при первом расхождении дальше совпадений уже не будет.
Сложность: O(n*m) по времени, O(1) по памяти.
Проверил на кейсах: [перечислить]
Ошибки/подводные: добавлять символ до проверки всех строк; неверно обрабатывать пустые строки; выход за границы индексов; возвращать "" после полного совпадения.
Что выучил: шаблон раннего выхода при первом расхождении; два способа решения (сканирование vs сортировка).
