site: LeetCode
code: LC0002
title: Add Two Numbers
difficulty: Medium
topics: [linked-list, math, carry, iteration, recursion]
status: unsolved
date: 2025-08-13
time_spent: "??:??"
goals: [работа с однонаправленным списком, перенос разряда (carry), шаблон dummy-head, покрытие edge-кейсов]

Условие (своими словами):
Даны два непустых однонаправленных списка, представляющих неотрицательные целые числа в обратном порядке (младший разряд — в голове). Каждый узел содержит одну цифру [0..9]. Нужно сложить числа и вернуть сумму в том же формате (новый список). Гарантируется отсутствие лидирующих нулей у исходных чисел (кроме самого числа 0).

Вход/Выход:
- Вход: ListNode l1, ListNode l2 (оба непустые)
- Выход: ListNode result (представляет сумму)

Примеры:
1) l1 = [2,4,3], l2 = [5,6,4] → [7,0,8]   // 342 + 465 = 807
2) l1 = [0], l2 = [0] → [0]
3) l1 = [9,9,9], l2 = [1] → [0,0,0,1]

Ограничения:
- Длины списков ≥ 1.
- Значения узлов — целые 0..9.
- Списки могут иметь разную длину.
- Числа могут быть большими (нельзя преобразовывать весь список в int/long).

Идея (без кода):
1) Идём по l1 и l2 одновременно. Храним перенос `carry` (0 или 1).
2) На каждом шаге: sum = (val1 или 0) + (val2 или 0) + carry; 
   текущая цифра = sum % 10; carry = sum / 10.
3) Добавляем узел с текущей цифрой в хвост результирующего списка (через dummy-head и текущий указатель).
4) В конце, если carry > 0 — добавляем финальный узел с carry.
5) Возвращаем список после dummy-head.

Сложность (target):
- Время: O(n + m), где n и m — длины списков.
- Память: O(n + m) для нового списка (или O(1) дополнительной, если переиспользовать узлы аккуратно).

Тесты (ручные):
- edge: [0] + [0] → [0]
- edge: [5] + [5] → [0,1]           // перенос на новый старший разряд
- edge: [9,9,9] + [1] → [0,0,0,1]   // каскадные переносы
- normal: [2,4,3] + [5,6,4] → [7,0,8]
- normal: [1,8] + [0] → [1,8]       // разная длина, без переноса
- normal: [1] + [9,9] → [0,0,1]     // разная длина, перенос тянется
- normal: [0,1] + [0,9] → [0,0,1]
- sanity: [9,9,9,9,9,9,9] + [9,9,9,9] → [8,9,9,9,0,0,0,1]

Отчёт по решению (короткий):
Подход: итерация по двум спискам с переносом и шаблоном dummy-head.
Почему работает: имитируем столбик сложения поразрядно, перенос идёт вперёд.
Сложность: время O(n+m), память O(n+m).
Проверил на кейсах: (перечислить).
Ошибки/подводные: забытый финальный перенос; неверная инициализация dummy/tail; изменение входных списков без нужды; путаница с порядком разрядов (reverse).
Что выучил: шаблон работы со списками (dummy-head), поразрядная арифметика, тестирование edge-кейсов переносов.