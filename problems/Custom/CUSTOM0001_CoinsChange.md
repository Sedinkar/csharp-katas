site: Custom(Qomeq interview, live coding)
code: CUSTOM0001
title: MinCoinsChange
difficulty: Easy
topics: [greedy, dynamic-programming]
status: solved

Условие (своими словами):
Даны сумма сдачи amount и отсортированный по возрастанию массив монет coins.
Нужно выдать сдачу максимально крупными монетами: на каждом шаге брать
самую большую монету, не превышающую текущий остаток. Результат вывести
как список номиналов через запятую. Если ровно составить сумму нельзя —
вывести "No change".

Важно: цель НЕ минимизировать количество монет; приоритет — более крупные номиналы.

Вход/Выход:
- Вход: amount: int (неотрицательный), coins: int[] (отсортирован по возрастанию, положительные значения)
- Выход: string — либо "a,b,c", либо "No change"

Примеры:
1) amount=15, coins=[1,5,10,25,100] → [10,5]
2) amount=6, coins=[1,3,4] → [4,1,1]
3) amount=41, coins=[1,5,10,25] → [25,10,5,1]
4) amount=3, coins=[5,10] → "Сдачи нет"
5) amount=0, coins=[1,5,10] → "Сдачи нет"
6) amount=14, coins=[7,5,3] → [7,7]
7) amount=9, coins=[2,5,4] → [5,4]

Ограничения:
- amount ≥ 0
- coins отсортирован по возрастанию
- все coins[i] > 0
- если amount меньше минимальной монеты → "No change"
- если на каком-то шаге нет монеты ≤ остатка → "No change"

Идея (без кода):
1) Идти по coins с конца (крупные→мелкие).
2) Пока текущая монета ≤ остатка — брать её и уменьшать остаток.
3) Перейти к следующей монете. В конце: остаток 0 → печатаем набор; иначе → "No change".

Сложность (target):
Время O(k + m) при уже отсортированном coins (k — число номиналов, m — количество выданных монет).
Память O(m) на список ответа.

Тесты (ручные):
- edge: amount=0, coins=[1,5,10] → "No change"
- edge: amount=1, coins=[2,4] → "No change"
- normal: amount=15, coins=[1,5,10,25,100] → "10,5"
- normal: amount=150, coins=[1,5,10,25,100] → "100,25,25"
- normal: amount=333, coins=[1,5,10,25,100] → "100,100,100,25,5,1,1,1"
- normal: amount=6, coins=[1,3,4] → "4,1,1"
- normal: amount=14, coins=[7,5,3] → "7,7"
- normal: amount=9, coins=[2,5,4] → "5,4"

Отчёт по решению (короткий):
Подход: жадный выбор крупнейшей доступной монеты; проход по отсортированному массиву с конца.
Почему работает: критерий задачи — «всегда максимально крупные» — прямо реализуется локальным выбором монеты.
Сложность: время O(k + m), память O(m).
Проверил на кейсах: [перечислить]
Ошибки/подводные: несогласованный текст "No change"; забыть двигаться к следующему номиналу; печатать с пробелами.
Что выучил: шаблон жадного выбора, влияние формулировки цели на алгоритм.